<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no" />
  <title>Juegos Eléctricos — Móvil</title>
  <meta name="theme-color" content="#0b1220" />

  <!-- Simple styling adaptado a pantallas móviles -->
  <style>
    :root{
      --bg:#071026;
      --card:#0f2233;
      --accent:#ffd24a;
      --muted:#9fb4c9;
      --success:#38d39f;
      --danger:#ff5c5c;
    }
    html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg),#021220);font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial; color:#e6f0f8}
    .app {
      box-sizing:border-box;
      padding:12px;
      max-width:900px;
      margin:0 auto;
      display:flex;
      flex-direction:column;
      gap:10px;
      height:100vh;
    }

    header{display:flex;align-items:center;gap:10px}
    header .logo{font-size:20px;font-weight:700;color:var(--accent)}
    header .meta{flex:1;text-align:right;font-size:12px;color:var(--muted)}

    /* Canvas area */
    .game-wrap{
      flex:1;
      background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);
      border-radius:14px;
      padding:10px;
      display:flex;
      flex-direction:column;
      gap:8px;
      min-height:320px;
      position:relative;
      overflow:hidden;
    }

    #gameCanvas{
      background:linear-gradient(180deg,#062734, #022022);
      border-radius:10px;
      width:100%;
      height:100%;
      display:block;
      touch-action:none; /* we handle touches */
    }

    .controls {
      display:flex;
      gap:8px;
      align-items:center;
      justify-content:space-between;
    }

    .btn {
      background:var(--card);
      color:var(--accent);
      padding:8px 12px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,0.03);
      font-weight:600;
      font-size:14px;
    }

    .hud {
      position:absolute;
      top:12px;
      left:12px;
      background:rgba(0,0,0,0.25);
      padding:8px 10px;
      border-radius:10px;
      font-size:13px;
      color:var(--muted);
      display:flex;
      gap:10px;
      align-items:center;
    }

    .toast {
      position:absolute;
      bottom:18px;
      left:50%;
      transform:translateX(-50%);
      background:rgba(0,0,0,0.5);
      padding:8px 14px;
      border-radius:999px;
      color:var(--accent);
      font-weight:600;
      display:none;
    }

    /* Small mobile adjustments */
    @media (max-width:420px){
      header .logo{font-size:18px}
      .btn{padding:8px 10px;font-size:13px}
    }
  </style>
</head>
<body>
  <div class="app" id="app">
    <header>
      <div class="logo">⚡ Juegos Eléctricos</div>
      <div class="meta">Nivel 1 · Dificultad: Fácil</div>
    </header>

    <div class="game-wrap" id="game-wrap">
      <!-- HUD -->
      <div class="hud" id="hud">
        <div id="objective">Objetivo: Conectar la lámpara</div>
        <div id="progress">Progreso: 0%</div>
      </div>

      <!-- Canvas para el juego -->
      <canvas id="gameCanvas" width="800" height="1400" aria-label="Área de juego táctil"></canvas>

      <div class="toast" id="toast">¡Correcto!</div>
    </div>

    <div class="controls">
      <button class="btn" id="btnHint">Pista</button>
      <button class="btn" id="btnReset">Reiniciar</button>
      <button class="btn" id="btnFullscreen">Pantalla completa</button>
    </div>
  </div>

  <script>
  /* =====================================================
     Versión móvil básica: arrastrar/soltar cables y tocar sockets.
     Estructura:
       - Canvas dibuja: sockets (puntos) y una lámpara (estado ON/OFF).
       - El usuario toca y arrastra desde un terminal (fase/neutro) y suelta en el socket.
       - Lógica simple de validación: si ambos terminales conectados, la bombilla enciende.
     ===================================================== */

  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d', {alpha:false});
  const toast = document.getElementById('toast');
  const progressEl = document.getElementById('progress');

  // Escala para pantallas móviles: ajusta canvas tamaño real al contenedor
  function resizeCanvas(){
    const rect = canvas.getBoundingClientRect();
    const ratio = window.devicePixelRatio || 1;
    canvas.width = Math.round(rect.width * ratio);
    canvas.height = Math.round(rect.height * ratio);
    ctx.setTransform(ratio,0,0,ratio,0,0);
    draw();
  }
  window.addEventListener('resize', resizeCanvas);
  setTimeout(resizeCanvas, 30);

  // Game objects (en unidades de CSS pixels)
  const sockets = [
    {id:'fase', x:60, y:120, r:18, color:'#ffb84d', type:'source', label:'Fase', connectedTo:null},
    {id:'neutro', x:60, y:220, r:18, color:'#a0d6ff', type:'source', label:'Neutro', connectedTo:null},
    {id:'lamp', x:canvas.clientWidth - 70, y:170, r:32, color:'#f5e6c4', type:'lamp', state:false}
  ];

  // For dynamic layout compute positions relative to canvas size
  function layoutSockets(){
    const w = canvas.clientWidth;
    const h = canvas.clientHeight;
    sockets[0].x = 40; sockets[0].y = Math.round(h*0.25);
    sockets[1].x = 40; sockets[1].y = Math.round(h*0.55);
    sockets[2].x = Math.round(w - 60); sockets[2].y = Math.round(h*0.4);
  }

  layoutSockets();

  // drag state
  let dragging = null; // {fromSocket, x, y}
  let lines = []; // {fromId, toX,toY, toId|null}

  // draw
  function draw(){
    layoutSockets();
    // background
    ctx.fillStyle = '#041a21';
    ctx.fillRect(0,0,canvas.clientWidth, canvas.clientHeight);

    // draw wires
    ctx.lineCap = 'round';
    lines.forEach(l => {
      const from = sockets.find(s=>s.id===l.fromId);
      ctx.strokeStyle = from ? from.color : '#ddd';
      ctx.lineWidth = 8;
      ctx.beginPath();
      ctx.moveTo(from.x, from.y);
      ctx.lineTo(l.toX,l.toY);
      ctx.stroke();
    });

    // draw dragging line
    if (dragging){
      ctx.strokeStyle = dragging.fromSocket.color;
      ctx.lineWidth = 8;
      ctx.beginPath();
      ctx.moveTo(dragging.fromSocket.x, dragging.fromSocket.y);
      ctx.lineTo(dragging.x, dragging.y);
      ctx.stroke();
    }

    // draw sockets
    sockets.forEach(s=>{
      if (s.type==='lamp'){
        // lamp circle + glow if on
        ctx.beginPath();
        ctx.fillStyle = s.state ? '#fff4c2' : '#f3e9d9';
        ctx.arc(s.x, s.y, s.r, 0, Math.PI*2);
        ctx.fill();
        ctx.lineWidth = 3;
        ctx.strokeStyle = s.state ? '#ffd24a' : '#b59d7a';
        ctx.stroke();

        // filament icon
        ctx.beginPath();
        ctx.strokeStyle = s.state ? '#b36a00' : '#6a5840';
        ctx.lineWidth = 2;
        ctx.moveTo(s.x-10,s.y+6);
        ctx.lineTo(s.x+10,s.y+6);
        ctx.stroke();
      } else {
        // source socket
        ctx.beginPath();
        ctx.fillStyle = s.color;
        ctx.arc(s.x, s.y, s.r, 0, Math.PI*2);
        ctx.fill();
        ctx.lineWidth = 2;
        ctx.strokeStyle = '#002';
        ctx.stroke();
      }

      // labels
      ctx.font = '14px system-ui,Arial';
      ctx.fillStyle = '#cfe9ff';
      ctx.textAlign = 'center';
      ctx.fillText(s.label || s.id, s.x, s.y + s.r + 16);
    });
  }

  // Utility: get socket under point
  function socketAt(x,y){
    for (let s of sockets){
      const dx = x - s.x;
      const dy = y - s.y;
      if (Math.sqrt(dx*dx+dy*dy) <= s.r + 8) return s;
    }
    return null;
  }

  // Convert touch/mouse events to canvas coords
  function getPos(clientX,clientY){
    const rect = canvas.getBoundingClientRect();
    return {x: clientX - rect.left, y: clientY - rect.top};
  }

  // Start drag from a source socket
  function startDrag(fromSocket, x, y){
    dragging = {fromSocket, x, y};
    draw();
  }

  // End drag: if released over a socket, create connection
  function endDrag(x,y){
    if (!dragging) return;
    const target = socketAt(x,y);
    if (target && target.id !== dragging.fromSocket.id){
      // register a wire ending at target
      lines.push({fromId: dragging.fromSocket.id, toX: target.x, toY: target.y, toId: target.id});
      // store connection mapping
      dragging.fromSocket.connectedTo = target.id;
      // if both fase and neutro connected to lamp -> light on
      checkLampState();
      showToast('Conectado: ' + dragging.fromSocket.label + ' → ' + target.label);
      updateProgress();
    } else {
      // cancel
    }
    dragging = null;
    draw();
  }

  // Check lamp: if lamp has two different connections from phase+neutral -> on
  function checkLampState(){
    const lamp = sockets.find(s=>s.type==='lamp');
    const fase = sockets.find(s=>s.id==='fase');
    const neutro = sockets.find(s=>s.id==='neutro');

    if (fase.connectedTo === lamp.id && neutro.connectedTo === lamp.id){
      lamp.state = true;
      showToast('La lámpara está ENCENDIDA', 1200);
    } else {
      lamp.state = false;
    }
    draw();
  }

  function showToast(msg, ms=900){
    toast.textContent = msg;
    toast.style.display = 'block';
    clearTimeout(toast._t);
    toast._t = setTimeout(()=> toast.style.display = 'none', ms);
  }

  function updateProgress(){
    const totalRequired = 2;
    const connected = ['fase','neutro'].filter(id=>{
      const s = sockets.find(x=>x.id===id);
      return s && s.connectedTo === 'lamp';
    }).length;
    const pct = Math.round((connected/totalRequired)*100);
    progressEl.textContent = 'Progreso: ' + pct + '%';
  }

  // Reset
  function resetGame(){
    lines = [];
    sockets.forEach(s=>{
      if (s.type === 'source') s.connectedTo = null;
      if (s.type === 'lamp') s.state = false;
    });
    updateProgress();
    draw();
  }

  // Touch / mouse handlers (support both)
  function onPointerDown(clientX, clientY){
    const p = getPos(clientX, clientY);
    const s = socketAt(p.x,p.y);
    // start only if touching a source-type socket (fase/neutro)
    if (s && s.type === 'source'){
      startDrag(s, p.x, p.y);
    }
  }

  function onPointerMove(clientX, clientY){
    if (!dragging) return;
    const p = getPos(clientX, clientY);
    dragging.x = p.x; dragging.y = p.y;
    draw();
  }

  function onPointerUp(clientX, clientY){
    const p = getPos(clientX, clientY);
    endDrag(p.x,p.y);
  }

  // Mouse support
  canvas.addEventListener('mousedown', e => { e.preventDefault(); onPointerDown(e.clientX,e.clientY); });
  window.addEventListener('mousemove', e => { if (dragging) { onPointerMove(e.clientX,e.clientY); }});
  window.addEventListener('mouseup', e => { if (dragging) onPointerUp(e.clientX,e.clientY); });

  // Touch support
  canvas.addEventListener('touchstart', e => {
    e.preventDefault();
    const t = e.changedTouches[0];
    onPointerDown(t.clientX, t.clientY);
  }, {passive:false});
  canvas.addEventListener('touchmove', e => {
    e.preventDefault();
    const t = e.changedTouches[0];
    onPointerMove(t.clientX, t.clientY);
  }, {passive:false});
  canvas.addEventListener('touchend', e => {
    e.preventDefault();
    const t = e.changedTouches[0];
    onPointerUp(t.clientX, t.clientY);
  }, {passive:false});

  // Buttons
  document.getElementById('btnReset').addEventListener('click', resetGame);
  document.getElementById('btnHint').addEventListener('click', ()=> showToast('Conecta Fase y Neutro a la lámpara'));
  document.getElementById('btnFullscreen').addEventListener('click', async ()=>{
    try {
      if (!document.fullscreenElement) await document.documentElement.requestFullscreen();
      else await document.exitFullscreen();
    } catch(e){ console.warn(e) }
  });

  // initial
  resetGame();
  draw();

  // Accessibility: allow keyboard connect for desktop testing
  window.addEventListener('keydown', (e)=>{
    if (e.key === '1') { sockets[0].connectedTo = 'lamp'; lines.push({fromId:'fase',toX:sockets[2].x,toY:sockets[2].y,toId:'lamp'}); checkLampState(); updateProgress(); }
    if (e.key === '2') { sockets[1].connectedTo = 'lamp'; lines.push({fromId:'neutro',toX:sockets[2].x,toY:sockets[2].y,toId:'lamp'}); checkLampState(); updateProgress(); }
    if (e.key === 'r') resetGame();
  });

  </script>
</body>
</html>
